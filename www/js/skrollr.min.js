/*!
 * skrollr core
 *
 * Alexander Prinzhorn - https://github.com/Prinzhorn/skrollr
 *
 * Free to use under terms of MIT license
 */
!function(a,b,c){"use strict";/*
	 * Global api.
	 */
var d=a.skrollr={get:function(){return sb},//Main entry point.
init:function(a){return sb||new V(a)},VERSION:"0.6.21"},e=Object.prototype.hasOwnProperty,f=a.Math,g=a.getComputedStyle,h,i,j="touchstart",k="touchmove",l="touchcancel",m="touchend",n="skrollable",o=n+"-before",p=n+"-between",q=n+"-after",r="skrollr",s="no-"+r,t=r+"-desktop",u=r+"-mobile",v="linear",w=1e3,x=.004,y=200,z="start",A="end",B="center",C="bottom",D="___skrollable_id",E=/^(?:input|textarea|button|select)$/i,F=/^\s+|\s+$/g,G=/^data(?:-(_\w+))?(?:-?(-?\d*\.?\d+p?))?(?:-?(start|end|top|center|bottom))?(?:-?(top|center|bottom))?$/,H=/\s*([\w\-\[\]]+)\s*:\s*(.+?)\s*(?:;|$)/gi,I=/^([a-z\-]+)\[(\w+)\]$/,J=/-([a-z])/g,K=function(a,b){return b.toUpperCase()},L=/[\-+]?[\d]*\.?[\d]+/g,M=/\{\?\}/g,N=/rgba?\(\s*-?\d+\s*,\s*-?\d+\s*,\s*-?\d+/g,O=/[a-z\-]+-gradient/g,P="",Q="",R=function(){//Only relevant prefixes. May be extended.
//Could be dangerous if there will ever be a CSS property which actually starts with "ms". Don't hope so.
var a=/^(?:O|Moz|webkit|ms)|(?:-(?:o|moz|webkit|ms)-)/;//Detect prefix for current browser by finding the first property using a prefix.
if(g){var b=g(i,null);for(var c in b)if(//We check the key and if the key is a number, we check the value as well, because safari's getComputedStyle returns some weird array-like thingy.
P=c.match(a)||+c==c&&b[c].match(a))break;//Did we even detect a prefix?
if(!P)return void(P=Q="");P=P[0],//We could have detected either a dashed prefix or this camelCaseish-inconsistent stuff.
"-"===P.slice(0,1)?(Q=P,//There's no logic behind these. Need a look up.
P={"-webkit-":"webkit","-moz-":"Moz","-ms-":"ms","-o-":"O"}[P]):Q="-"+P.toLowerCase()+"-"}},S=function(){var b=a.requestAnimationFrame||a[P.toLowerCase()+"RequestAnimationFrame"],c=qb();return(Ob||!b)&&(b=function(b){//How long did it take to render?
var d=qb()-c,e=f.max(0,1e3/60-d);return a.setTimeout(function(){c=qb(),b()},e)}),b},T=function(){var b=a.cancelAnimationFrame||a[P.toLowerCase()+"CancelAnimationFrame"];return(Ob||!b)&&(b=function(b){return a.clearTimeout(b)}),b},U={begin:function(){return 0},end:function(){return 1},linear:function(a){return a},quadratic:function(a){return a*a},cubic:function(a){return a*a*a},swing:function(a){return-f.cos(a*f.PI)/2+.5},sqrt:function(a){return f.sqrt(a)},outCubic:function(a){return f.pow(a-1,3)+1},//see https://www.desmos.com/calculator/tbr20s8vd2 for how I did this
bounce:function(a){var b;if(.5083>=a)b=3;else if(.8489>=a)b=9;else if(.96208>=a)b=27;else{if(!(.99981>=a))return 1;b=91}return 1-f.abs(3*f.cos(a*b*1.028)/b)}};/**
	 * Constructor.
	 */
function V(c){//We allow defining custom easings or overwrite existing.
if(h=b.documentElement,i=b.body,R(),sb=this,c=c||{},zb=c.constants||{},c.easing)for(var d in c.easing)U[d]=c.easing[d];Nb=c.edgeStrategy||"set",vb={//Function to be called right before rendering.
beforerender:c.beforerender,//Function to be called right after finishing rendering.
render:c.render},//forceHeight is true by default
wb=c.forceHeight!==!1,wb&&(yb=c.scale||1),Ab=c.mobileDeceleration||x,Ib=c.smoothScrolling!==!1,Jb=c.smoothScrollingDuration||y,//Dummy object. Will be overwritten in the _render method when smooth scrolling is calculated.
Kb={targetTop:sb.getScrollTop()},//A custom check function may be passed.
Ob=(c.mobileCheck||function(){return/Android|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent||navigator.vendor||a.opera)})(),Ob?(ub=b.getElementById("skrollr-body"),//Detect 3d transform if there's a skrollr-body (only needed for #skrollr-body).
ub&&fb(),W(),nb(h,[r,u],[s])):nb(h,[r,t],[s]),//Triggers parsing of elements and a first reflow.
sb.refresh(),gb(a,"resize orientationchange",function(){var a=h.clientWidth,b=h.clientHeight;//Only reflow if the size actually changed (#271).
(b!==Fb||a!==Eb)&&(Fb=b,Eb=a,Gb=!0)});var e=S();//Let's go.
return function f(){Z(),Sb=e(f)}(),sb}/**
	 * (Re)parses some or all elements.
	 */
V.prototype.refresh=function(a){var d,e,f=!1;for(//Completely reparse anything without argument.
a===c?(//Ignore that some elements may already have a skrollable ID.
f=!0,tb=[],Mb=0,a=b.getElementsByTagName("*"))://We accept a single element or an array of elements.
a=[].concat(a),d=0,e=a.length;e>d;d++){var g=a[d],h=g,i=[],j=Ib,k=Nb;if(g.attributes){for(//Iterate over all attributes and search for key frame attributes.
var l=0,m=g.attributes.length;m>l;l++){var o=g.attributes[l];if("data-anchor-target"!==o.name)//Global smooth scrolling can be overridden by the element attribute.
if("data-smooth-scrolling"!==o.name)//Global edge strategy can be overridden by the element attribute.
if("data-edge-strategy"!==o.name){var p=o.name.match(G);if(null!==p){var q={props:o.value,//Point back to the element as well.
element:g};i.push(q);var r=p[1];r&&(//Strip the underscore prefix.
q.constant=r.substr(1));//Get the key frame offset.
var s=p[2];//Is it a percentage offset?
/p$/.test(s)?(q.isPercentage=!0,q.offset=(0|s.slice(0,-1))/100):q.offset=0|s;var t=p[3],u=p[4]||t;//"absolute" (or "classic") mode, where numbers mean absolute scroll offset.
t&&t!==z&&t!==A?(q.mode="relative",q.anchors=[t,u]):(q.mode="absolute",//data-end needs to be calculated after all key frames are known.
t===A?q.isEnd=!0:q.isPercentage||(//For data-start we can already set the key frame w/o calculations.
//#59: "scale" options should only affect absolute mode.
q.offset=q.offset*yb))}}else k=o.value;else j="off"!==o.value;else if(h=b.querySelector(o.value),null===h)throw'Unable to find anchor target "'+o.value+'"'}//Does this element have key frames?
if(i.length){//Will hold the original style and class attributes before we controlled the element (see #80).
var v,w,x;!f&&D in g?(//We already have this element under control. Grab the corresponding skrollable id.
x=g[D],v=tb[x].styleAttr,w=tb[x].classAttr):(//It's an unknown element. Asign it a new skrollable id.
x=g[D]=Mb++,v=g.style.cssText,w=mb(g)),tb[x]={element:g,styleAttr:v,classAttr:w,anchorTarget:h,keyFrames:i,smoothScrolling:j,edgeStrategy:k},nb(g,[n],[])}}}for(//Reflow for the first time.
jb(),//Now that we got all key frame numbers right, actually parse the properties.
d=0,e=a.length;e>d;d++){var y=tb[a[d][D]];y!==c&&(//Parse the property string to objects
$(y),//Fill key frames with missing properties from left and right
ab(y))}return sb},/**
	 * Transform "relative" mode to "absolute" mode.
	 * That is, calculate anchor position and offset of element.
	 */
V.prototype.relativeToAbsolute=function(a,b,c){var d=h.clientHeight,e=a.getBoundingClientRect(),f=e.top,g=e.bottom-e.top;//Compensate scrolling since getBoundingClientRect is relative to viewport.
return b===C?f-=d:b===B&&(f-=d/2),c===C?f+=g:c===B&&(f+=g/2),f+=sb.getScrollTop(),f+.5|0},/**
	 * Animates scroll top to new position.
	 */
V.prototype.animateTo=function(a,b){b=b||{};var d=qb(),e=sb.getScrollTop();//Setting this to a new value will automatically cause the current animation to stop, if any.
//Don't queue the animation if there's nothing to animate.
return Hb={startTop:e,topDiff:a-e,targetTop:a,duration:b.duration||w,startTime:d,endTime:d+(b.duration||w),easing:U[b.easing||v],done:b.done},Hb.topDiff||(Hb.done&&Hb.done.call(sb,!1),Hb=c),sb},/**
	 * Stops animateTo animation.
	 */
V.prototype.stopAnimateTo=function(){Hb&&Hb.done&&Hb.done.call(sb,!0),Hb=c},/**
	 * Returns if an animation caused by animateTo is currently running.
	 */
V.prototype.isAnimatingTo=function(){return!!Hb},V.prototype.setScrollTop=function(b,c){return Lb=c===!0,Ob?Pb=f.min(f.max(b,0),xb):a.scrollTo(0,b),sb},V.prototype.getScrollTop=function(){return Ob?Pb:a.pageYOffset||h.scrollTop||i.scrollTop||0},V.prototype.getMaxScrollTop=function(){return xb},V.prototype.on=function(a,b){return vb[a]=b,sb},V.prototype.off=function(a){return delete vb[a],sb},V.prototype.destroy=function(){var a=T();a(Sb),ib(),nb(h,[s],[r,t,u]);for(var b=0,e=tb.length;e>b;b++)eb(tb[b].element);h.style.overflow=i.style.overflow="auto",h.style.height=i.style.height="auto",ub&&d.setStyle(ub,"transform","none"),sb=c,ub=c,vb=c,wb=c,xb=0,yb=1,zb=c,Ab=c,Bb="down",Cb=-1,Eb=0,Fb=0,Gb=!1,Hb=c,Ib=c,Jb=c,Kb=c,Lb=c,Mb=0,Nb=c,Ob=!1,Pb=0,Qb=c};/*
		Private methods.
	*/
var W=function(){var d,e,g,n,o,p,q,r,s,t,u,v;gb(h,[j,k,l,m].join(" "),function(a){var h=a.changedTouches[0];n=a.target;//We don't want text nodes.
while(3===n.nodeType)n=n.parentNode;switch(o=h.clientY,p=h.clientX,t=a.timeStamp,E.test(n.tagName)||a.preventDefault(),a.type){case j://The last element we tapped on.
d&&d.blur(),sb.stopAnimateTo(),d=n,e=q=o,g=p,s=t;break;case k://Prevent default event on touchIgnore elements in case they don't have focus yet.
E.test(n.tagName)&&b.activeElement!==n&&a.preventDefault(),r=o-q,v=t-u,sb.setScrollTop(Pb-r,!0),q=o,u=t;break;default:case l:case m:var i=e-o,w=g-p,x=w*w+i*i;//Check if it was more like a tap (moved less than 7px).
if(49>x){if(!E.test(d.tagName)){d.focus();//It was a tap, click the element.
var y=b.createEvent("MouseEvents");y.initMouseEvent("click",!0,!0,a.view,1,h.screenX,h.screenY,h.clientX,h.clientY,a.ctrlKey,a.altKey,a.shiftKey,a.metaKey,0,null),d.dispatchEvent(y)}return}d=c;var z=r/v;//Cap speed at 3 pixel/ms.
z=f.max(f.min(z,3),-3);var A=f.abs(z/Ab),B=z*A+.5*Ab*A*A,C=sb.getScrollTop()-B,D=0;//Change duration proportionally when scrolling would leave bounds.
C>xb?(D=(xb-C)/B,C=xb):0>C&&(D=-C/B,C=0),A*=1-D,sb.animateTo(C+.5|0,{easing:"outCubic",duration:A})}}),//Just in case there has already been some native scrolling, reset it.
a.scrollTo(0,0),h.style.overflow=i.style.overflow="hidden"},X=function(){var a=h.clientHeight,b=kb(),c,d,e,g,i,j,k,l,m,n,o;for(//First process all relative-mode elements and find the max key frame.
l=0,m=tb.length;m>l;l++)for(c=tb[l],d=c.element,e=c.anchorTarget,g=c.keyFrames,i=0,j=g.length;j>i;i++)k=g[i],n=k.offset,o=b[k.constant]||0,k.frame=n,k.isPercentage&&(//Convert the offset to percentage of the viewport height.
n*=a,//Absolute + percentage mode.
k.frame=n),"relative"===k.mode&&(eb(d),k.frame=sb.relativeToAbsolute(e,k.anchors[0],k.anchors[1])-n,eb(d,!0)),k.frame+=o,//Only search for max key frame when forceHeight is enabled.
wb&&!k.isEnd&&k.frame>xb&&(xb=k.frame);for(//#133: The document can be larger than the maxKeyFrame we found.
xb=f.max(xb,lb()),//Now process all data-end keyframes.
l=0,m=tb.length;m>l;l++){for(c=tb[l],g=c.keyFrames,i=0,j=g.length;j>i;i++)k=g[i],o=b[k.constant]||0,k.isEnd&&(k.frame=xb-k.offset+o);c.keyFrames.sort(rb)}},Y=function(a,b){for(//Iterate over all skrollables.
var c=0,f=tb.length;f>c;c++){var g=tb[c],h=g.element,i=g.smoothScrolling?a:b,j=g.keyFrames,k=j[0].frame,l=j[j.length-1].frame,m=k>i,r=i>l,s=j[m?0:j.length-1],t,u;//If we are before/after the first/last frame, set the styles according to the given edge strategy.
if(m||r){//Check if we already handled this edge case last time.
//Note: using setScrollTop it's possible that we jumped from one edge to the other.
if(m&&-1===g.edge||r&&1===g.edge)continue;switch(//Add the skrollr-before or -after class.
nb(h,[m?o:q],[o,p,q]),//Remember that we handled the edge case (before/after the first/last keyframe).
g.edge=m?-1:1,g.edgeStrategy){case"reset":eb(h);continue;case"ease"://Handle this case like it would be exactly at first/last keyframe and just pass it on.
i=s.frame;break;default:case"set":var v=s.props;for(t in v)e.call(v,t)&&(u=db(v[t].value),d.setStyle(h,t,u));continue}}else//Did we handle an edge last time?
0!==g.edge&&(nb(h,[n,p],[o,q]),g.edge=0);for(//Find out between which two key frames we are right now.
var w=0,x=j.length-1;x>w;w++)if(i>=j[w].frame&&i<=j[w+1].frame){var y=j[w],z=j[w+1];for(t in y.props)if(e.call(y.props,t)){var A=(i-y.frame)/(z.frame-y.frame);//Transform the current progress using the given easing function.
A=y.props[t].easing(A),//Interpolate between the two values
u=cb(y.props[t].value,z.props[t].value,A),u=db(u),d.setStyle(h,t,u)}break}}},Z=function(){Gb&&(Gb=!1,jb());//We may render something else than the actual scrollbar position.
var a=sb.getScrollTop(),b,e=qb(),f;//Before actually rendering handle the scroll animation, if any.
if(Hb)//It's over
e>=Hb.endTime?(a=Hb.targetTop,b=Hb.done,Hb=c):(//Map the current progress to the new progress using given easing function.
f=Hb.easing((e-Hb.startTime)/Hb.duration),a=Hb.startTop+f*Hb.topDiff|0),sb.setScrollTop(a,!0);else if(!Lb){var g=Kb.targetTop-a;//The user scrolled, start new smooth scrolling.
g&&(Kb={startTop:Cb,topDiff:a-Cb,targetTop:a,startTime:Db,endTime:Db+Jb}),//Interpolate the internal scroll position (not the actual scrollbar).
e<=Kb.endTime&&(//Map the current progress to the new progress using easing function.
f=U.sqrt((e-Kb.startTime)/Jb),a=Kb.startTop+f*Kb.topDiff|0)}//Did the scroll position even change?
if(//That's were we actually "scroll" on mobile.
Ob&&ub&&//Set the transform ("scroll it").
d.setStyle(ub,"transform","translate(0, "+-Pb+"px) "+Qb),Lb||Cb!==a){//Remember in which direction are we scrolling?
Bb=a>Cb?"down":Cb>a?"up":Bb,Lb=!1;var h={curTop:a,lastTop:Cb,maxTop:xb,direction:Bb},i=vb.beforerender&&vb.beforerender.call(sb,h);//The beforerender listener function is able the cancel rendering.
i!==!1&&(//Now actually interpolate all the styles.
Y(a,sb.getScrollTop()),//Remember when we last rendered.
Cb=a,vb.render&&vb.render.call(sb,h)),b&&b.call(sb,!1)}Db=e},$=function(a){for(//Iterate over all key frames
var b=0,c=a.keyFrames.length;c>b;b++){var d=a.keyFrames[b],e,f,g,h={},i;while(null!==(i=H.exec(d.props)))g=i[1],f=i[2],e=g.match(I),//Is there an easing specified for this prop?
null!==e?(g=e[1],e=e[2]):e=v,//Exclamation point at first position forces the value to be taken literal.
f=f.indexOf("!")?_(f):[f.slice(1)],//Save the prop for this key frame with his value and easing function
h[g]={value:f,easing:U[e]};d.props=h}},_=function(a){var b=[];//One special case, where floats don't work.
//We replace all occurences of rgba colors
//which don't use percentage notation with the percentage notation.
//Handle prefixing of "gradient" values.
//For now only the prefixed value will be set. Unprefixed isn't supported anyway.
//Now parse ANY number inside this string and create a format string.
//Add the formatstring as first value.
return N.lastIndex=0,a=a.replace(N,function(a){return a.replace(L,function(a){return a/255*100+"%"})}),Q&&(O.lastIndex=0,a=a.replace(O,function(a){return Q+a})),a=a.replace(L,function(a){return b.push(+a),"{?}"}),b.unshift(a),b},ab=function(a){//Will collect the properties key frame by key frame
var b={},c,d;for(//Iterate over all key frames from left to right
c=0,d=a.keyFrames.length;d>c;c++)bb(a.keyFrames[c],b);for(//Now do the same from right to fill the last gaps
b={},//Iterate over all key frames from right to left
c=a.keyFrames.length-1;c>=0;c--)bb(a.keyFrames[c],b)},bb=function(a,b){var c;//For each key frame iterate over all right hand properties and assign them,
//but only if the current key frame doesn't have the property by itself
for(c in b)//The current frame misses this property, so assign it.
e.call(a.props,c)||(a.props[c]=b[c]);//Iterate over all props of the current frame and collect them
for(c in a.props)b[c]=a.props[c]},cb=function(a,b,c){var d,e=a.length;//They both need to have the same length
if(e!==b.length)throw"Can't interpolate between \""+a[0]+'" and "'+b[0]+'"';//Add the format string as first element.
var f=[a[0]];for(d=1;e>d;d++)//That's the line where the two numbers are actually interpolated.
f[d]=a[d]+(b[d]-a[d])*c;return f},db=function(a){var b=1;return M.lastIndex=0,a[0].replace(M,function(){return a[b++]})},eb=function(a,b){//We accept a single element or an array of elements.
a=[].concat(a);for(var c,d,e=0,f=a.length;f>e;e++)d=a[e],c=tb[d[D]],//Couldn't find the skrollable for this DOM element.
c&&(b?(//Reset class and style to the "dirty" (set by skrollr) values.
d.style.cssText=c.dirtyStyleAttr,nb(d,c.dirtyClassAttr)):(//Remember the "dirty" (set by skrollr) class and style.
c.dirtyStyleAttr=d.style.cssText,c.dirtyClassAttr=mb(d),//Reset class and style to what it originally was.
d.style.cssText=c.styleAttr,nb(d,c.classAttr)))},fb=function(){Qb="translateZ(0)",d.setStyle(ub,"transform",Qb);var a=g(ub),b=a.getPropertyValue("transform"),c=a.getPropertyValue(Q+"transform"),e=b&&"none"!==b||c&&"none"!==c;e||(Qb="")};/**
	 * Set the CSS property on the given element. Sets prefixed properties as well.
	 */
d.setStyle=function(a,b,c){var d=a.style;//Make sure z-index gets a <integer>.
//This is the only <integer> case we need to handle.
if(//Camel case.
b=b.replace(J,K).replace("-",""),"zIndex"===b)//If it's not a number, don't touch it.
//It could for example be "auto" (#351).
d[b]=isNaN(c)?c:""+(0|c);else if("float"===b)d.styleFloat=d.cssFloat=c;else//Need try-catch for old IE.
try{//Set prefixed property if there's a prefix.
P&&(d[P+b.slice(0,1).toUpperCase()+b.slice(1)]=c),//Set unprefixed.
d[b]=c}catch(e){}};/**
	 * Cross browser event handling.
	 */
var gb=d.addEvent=function(b,c,d){var e=function(b){//Normalize IE event stuff.
return b=b||a.event,b.target||(b.target=b.srcElement),b.preventDefault||(b.preventDefault=function(){b.returnValue=!1}),d.call(this,b)};c=c.split(" ");for(var f,g=0,h=c.length;h>g;g++)f=c[g],b.addEventListener?b.addEventListener(f,d,!1):b.attachEvent("on"+f,e),//Remember the events to be able to flush them later.
Rb.push({element:b,name:f,listener:d})},hb=d.removeEvent=function(a,b,c){b=b.split(" ");for(var d=0,e=b.length;e>d;d++)a.removeEventListener?a.removeEventListener(b[d],c,!1):a.detachEvent("on"+b[d],c)},ib=function(){for(var a,b=0,c=Rb.length;c>b;b++)a=Rb[b],hb(a.element,a.name,a.listener);Rb=[]},jb=function(){var a=sb.getScrollTop();//Will be recalculated by _updateDependentKeyFrames.
xb=0,wb&&!Ob&&(//un-"force" the height to not mess with the calculations in _updateDependentKeyFrames (#216).
i.style.height="auto"),X(),wb&&!Ob&&(//"force" the height.
i.style.height=xb+h.clientHeight+"px"),//The scroll offset may now be larger than needed (on desktop the browser/os prevents scrolling farther than the bottom).
Ob?sb.setScrollTop(f.min(sb.getScrollTop(),xb))://Remember and reset the scroll pos (#217).
sb.setScrollTop(a,!0),Lb=!0},kb=function(){var a=h.clientHeight,b={},c,d;for(c in zb)d=zb[c],"function"==typeof d?d=d.call(sb):/p$/.test(d)&&(d=d.slice(0,-1)/100*a),b[c]=d;return b},lb=function(){var a=ub&&ub.offsetHeight||0,b=f.max(a,i.scrollHeight,i.offsetHeight,h.scrollHeight,h.offsetHeight,h.clientHeight);return b-h.clientHeight},mb=function(b){var c="className";//SVG support by using className.baseVal instead of just className.
return a.SVGElement&&b instanceof a.SVGElement&&(b=b[c],c="baseVal"),b[c]},nb=function(b,d,e){var f="className";//When remove is ommited, we want to overwrite/set the classes.
if(//SVG support by using className.baseVal instead of just className.
a.SVGElement&&b instanceof a.SVGElement&&(b=b[f],f="baseVal"),e===c)return void(b[f]=d);for(//Cache current classes. We will work on a string before passing back to DOM.
var g=b[f],h=0,i=e.length;i>h;h++)g=pb(g).replace(pb(e[h])," ");g=ob(g);for(//All classes to be added.
var j=0,k=d.length;k>j;j++)//Only add if el not already has class.
-1===pb(g).indexOf(pb(d[j]))&&(g+=" "+d[j]);b[f]=ob(g)},ob=function(a){return a.replace(F,"")},pb=function(a){return" "+a+" "},qb=Date.now||function(){return+new Date},rb=function(a,b){return a.frame-b.frame},sb,tb,ub,vb,wb,xb=0,yb=1,zb,Ab,Bb="down",Cb=-1,Db=qb(),Eb=0,Fb=0,Gb=!1,Hb,Ib,Jb,Kb,Lb,Mb=0,Nb,Ob=!1,Pb=0,Qb,Rb=[],Sb}(window,document);